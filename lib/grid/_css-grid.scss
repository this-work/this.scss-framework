////
///
/// Grid (CSS Grid) System
///
/// @group CSS Grid
/// @since 2.0.0
///
////



///
/// Grid config array.
///
/// @prop {String} grid -  Name of the grid
/// @prop {Number} grid.columns - Count of columns for the grid
/// @prop {Number} grid.column-width - Columns width value with unit or minmax function
/// @prop {Number} grid.column-gutter - Columns gutter value in %, em or px
/// @prop {Number} grid.rows - [`optional`] Count of rows for the grid. Zero or 'auto' for auto rows.
/// @prop {Number} grid.rows-height - [`optional`] Row height value with unit or minmax function. Only used when rows not zero/auto.
/// @prop {Number} grid.rows-gutter - Rows gutter value in %, em or px
/// @prop {String} grid.grid-flow - Method of the grid flow
/// @prop {bool} grid.column-first - Indicator if row starts with a column
///
/// @type array
/// @example scss - Set up two grids
/// $grid-config: (
///     'default': (
///         'columns': 12,
///         'column-width': 1fr,
///         'column-gutter': 15px,
///         'rows': auto,
///         'rows-height': auto,
///         'row-gutter': 15px,
///         'grid-flow': row,
///         'column-first': true
///     ),
///     'grid-2': (
///         'columns': 14,
///         'column-width': minmax(min-content, 100px),
///         'column-gutter': 1.25%,
///         'rows': 0,
///         'rows-height': 0,
///         'row-gutter': 0,
///         'grid-flow': row,
///         'column-first': true
///     ),
/// );
///
$grid-config: (
    'default': (
        'columns': 12,
        'column-width': 1fr,
        'column-gutter': 1.5%,
        'rows': 0,
        'rows-height': 0,
        'row-gutter': 0,
        'grid-flow': row,
        'column-first': true
    )
) !default;



///
/// Generate a IE 10+ compatible repeated column string with gutters as columns.
/// Only to polyfill the repeat function and gaps/gutter.
///
/// @param {number} $type-count - Number of columns
/// @param {number} $type-width - Width of a column
/// @param {number} $type-gutter - Size of the gutter between columns
///
/// @return {string} - Unquoted compatible column string.
///
@function _get-grid-compatible-repeat-value(
    $type-count,
    $type-width,
    $type-gutter
) {

    $compatible-repeat-value: 0px $type-width;

    @for $count from 2 through $type-count {
        $compatible-repeat-value: $compatible-repeat-value + " " + $type-gutter + " " + minmax(1px, $type-width);
    }

    @return unquote($compatible-repeat-value);
}



///
/// Get the column width as percentage
///
/// @param {Number} $column-number - Span of columns
/// @param {string} $grid-name [$default-grid] - [`optional`] Name of the grid, default is the $default-grid
///
/// @return {Number} Column width as percentage
///
/// @example scss - Set the width to 4 columns of the grid
/// width: grid-column-width-percentage(4);
///
@function grid-column-width-percentage(
    $column-number,
    $grid-name: $default-grid
) {

    $columns: number(_get-grid-data('columns', $grid-name));

    $gutter: number(_get-grid-data('column-gutter', $grid-name));

    $gutter : if(unit($gutter) == '%', $gutter, 0);

    $total-gutter: ($columns - 1) * $gutter;

    $single-column-width: (100% - $total-gutter) / $columns;

    @return ($single-column-width * $column-number) + ($gutter * ($column-number - 1));
}



///
/// Generate grid context styles with given expanded arguments to
/// create a css grid container.
///
/// @prop {Number} $columns - Count of columns for the grid
/// @prop {Number} $column-width - Columns width value with unit or minmax function
/// @prop {Number} $column-gutter - Columns gutter value in %, em or px
/// @prop {Number} $rows - Count of rows for the grid. Zero or 'auto' for auto rows.
/// @prop {Number} $rows-height - Row height value with unit or minmax function. Only used when rows not zero/auto.
/// @prop {Number} $rows-gutter - Rows gutter value in %, em or px
/// @prop {String} $grid-flow - Method of the grid flow
/// @prop {bool} $column-first - Indicator if row starts with a column
///
/// @example scss - Generate a 12 column grid with a 10px gap and autoplacement rows.
/// include _grid-context(12, 1fr, 10px, 0, 0, 0, row, true);
///
@mixin _grid-context(
    $columns,
    $column-width: 1fr,
    $column-gutter: 0,
    $rows: 0,
    $rows-height: 0,
    $row-gutter: 0,
    $grid-flow: row,
    $column-first: true
) {

    $column-gutter: unitize($column-gutter);
    $row-gutter: unitize($row-gutter);
    $column-width: unitize($column-width);

    display: -ms-grid;
    display: grid;

    grid-column-gap:$column-gutter;
    grid-row-gap:$row-gutter;

    @if ($columns) {

        /* autoprefixer: ignore next */
        grid-auto-flow: $grid-flow;

        -ms-grid-columns: _get-grid-compatible-repeat-value($columns, $column-width, $column-gutter);
        grid-template-columns: repeat( $columns, minmax(1px, $column-width));

        @if ($rows and $rows-height and $rows != auto and $rows > 0 and $rows-height != auto) {

            $rows-height: unitize($rows-height);

            -ms-grid-rows: _get-grid-compatible-repeat-value($rows, $rows-height, $row-gutter);
            grid-template-rows: repeat( $rows, $rows-height );

        }@else{

            -ms-grid-rows:0px auto $row-gutter;

        }
    }

    @if not ($column-first) {
        padding-left: $column-gutter;
        padding-right: $column-gutter;
    }

}



///
/// Generate grid context styles from the grid config.
///
/// @param {string} $grid-name [$default-grid] - [`optional`] Name of the grid, default is the $default-grid
///
/// @example scss - Set all context styles
/// include grid-context();
///
@mixin grid-context(
    $grid-name:     $default-grid,
    $columns:       _get-grid-data('columns', $grid-name),
    $column-width:  _get-grid-data('column-width', $grid-name),
    $column-gutter: _get-grid-data('column-gutter', $grid-name),
    $rows:          _get-grid-data('rows', $grid-name),
    $rows-height:   _get-grid-data('rows-height', $grid-name),
    $row-gutter:    _get-grid-data('row-gutter', $grid-name),
    $grid-flow:     _get-grid-data('grid-flow', $grid-name),
    $column-first:  _get-grid-data('column-first', $grid-name)
) {

    @include _grid-context($columns, $column-width, $column-gutter, $rows, $rows-height, $row-gutter, $grid-flow, $column-first);

}



///
/// Generate a IE compatible grid column style for the polyfill.
///
/// @param {array} $definition [1fr] - [`optional`] Array of column definitions
/// @param {number} $gutter [0px] - [`optional`] Gutter between the columns
///
@mixin grid-template-columns(
    $definition,
    $column-gutter: 0px
) {

    $custom-columns: nth($definition, 1);
    $compatible-custom-columns: "0px " + nth($definition, 1);

    @for $count from 2 through length($definition) {

        $custom-columns: $custom-columns + " " + nth($definition, $count);

        $compatible-custom-columns: $compatible-custom-columns + " " + $column-gutter + " " + nth($definition, $count);

    }

    grid-column-gap:$column-gutter;

    -ms-grid-columns: unquote($compatible-custom-columns);

    grid-template-columns: unquote($custom-columns);

}



///
/// Generate IE 10+ compatible column start style with observance
/// to the gap polyfill for older browsers.
///
/// @prop {number} $x - x postion of the cells position.
///
@mixin grid-cell-column-start($x){

    @if ($x) {
        -ms-grid-column: ($x * 2);
        grid-column-start: $x;
    } @else {
        -ms-grid-column: 1;
        grid-column-start: unset;
    }

}



///
/// Generate IE 10+ compatible row start style with observance
/// to the gap polyfill for older browsers.
///
/// @prop {number} $y - Y postion of the cells position.
///
@mixin grid-cell-row-start($y){

    @if ($y) {
        -ms-grid-row:($y * 2);
        grid-row-start:$y;
    } @else {
        -ms-grid-row: 1;
        grid-row-start: unset;
    }

}



///
/// Generate IE 10+ compatible cell position styles with observance
/// to the gap polyfill for older browsers. Both attributes are optional.
///
/// @prop {number} $x - X postion of the cells position.
/// @prop {number} $y - Y postion of the cells position.
///
@mixin grid-cell-position(
    $x: false,
    $y: false
) {

    @include grid-cell-column-start($x);

    @include grid-cell-row-start($y);

}



///
/// Generate IE 10+ compatible column width style with observance
/// to the gap polyfill for older browsers.
///
/// @prop {number} $width - Columns to span.
///
@mixin grid-cell-width($width){
    $width: number(#{$width});
    -ms-grid-column-span:(($width * 2) - 1);
    grid-column-end:span #{$width};

}



///
/// Generate IE 10+ compatible row height style with observance
/// to the gap polyfill for older browsers.
///
/// @prop {number} $height - Rows to span.
///
@mixin grid-cell-height($height){
    $width: number(#{$height});
    -ms-grid-row-span:(($height * 2) - 1);
    grid-row-end:span #{$height};

}



///
/// Generate IE 10+ compatible cell size styles with observance
/// to the gap polyfill for older browsers. Both attributes are optional.
///
/// @prop {number} $width - Columns to span.
/// @prop {number} $height - Rows to span.
///
@mixin grid-cell-size(
    $width: false,
    $height: false
) {
    @if ($width) {
        @include grid-cell-width($width);
    }

    @if ($height) {
        @include grid-cell-height($height);
    }

}



///
/// Generate a margin to include the next gap.
///
/// @param {string} $direction - Direction of next gap (left, right, both)
/// @param {number} $columns - Size of the current grid element (1, 2, 3 ...)
/// @param {string} $grid-name [$default-grid] - [`optional`] Name of the grid, default is the $default-grid
///
@mixin grid-cell-push-gap($direction, $columns, $grid-name: $default-grid) {

    $column-gutter: number(_get-grid-data('column-gutter', $grid-name));

    @if(unit($column-gutter) == '%') {
        margin-#{$direction}: calc( ((#{strip-unit($column-gutter)} * (100% * 100 / #{strip-unit(grid-column-width-percentage($columns))})) / 100 ) * -1);
    } @else {
        margin-#{$direction}: calc( #{$column-gutter} * -1 );
    }

}



///
/// Generate a margin to push or pull the cell to the
/// wrapper or the viewport border. These mixin needs the view/mediaquery functions
/// and the utils/page functions.
///
/// @param {string} $offsetType ['start'] - [`optional`] Direction of offset (start, end, complete)
/// @param {string|number} $offsetWidth ['viewport'] - [`optional`] Width of offset (viewport, page)
/// @param {string} $offsetVisbility ['m'] - [`optional`] The breakpoint from which width the offset is visible
/// @param {string} $offsetVisbilityDirection ['above'] - [`optional`] The direction of the offset visbility
/// @param {string} $grid-name [$default-grid] - [`optional`] Name of the grid, default is the $default-grid
/// @param {array} $site-area-config [$site-area-columns] - [`optional`] Responsive declaration of the site area columns
///
@mixin grid-cell-offset(
    $offsetType: 'start',
    $offsetWidth: 'viewport',
    $offsetVisbility: 'm',
    $offsetVisbilityDirection: 'above',
    $grid-name: $default-grid,
    $site-area-config: $site-area-columns
) {

    $direction: left;

    @if ($offsetType == 'end') {
        $direction: right;
    }

    @if ($offsetType == 'complete') {
        @include grid-cell-offset('end', $offsetWidth, $offsetVisbility, $offsetVisbilityDirection, $grid-name, $site-area-config);
    }

    $largest-breakpoint: 0px;
    $largest-breakpoint-content-width: 0px;

    @if (type-of($offsetWidth) == 'number') {

        margin-#{$direction}: $offsetWidth * -1;

    } @else {

        @each $breakpoint, $config in sort-breakpoints($site-area-columns) {

            @if (($offsetVisbilityDirection == 'above' and strip-unit($breakpoint) >= strip-unit(breakpoint($offsetVisbility))) or ($offsetVisbilityDirection == 'below' and strip-unit($breakpoint) < strip-unit(breakpoint($offsetVisbility)))) {

                @if ($largest-breakpoint < $breakpoint) {
                    $largest-breakpoint: $breakpoint;
                    $largest-breakpoint-content-width: map-get($config, 'content');
                }

                @include possible-mediaquery($breakpoint) {
                    @if ($offsetWidth == 'viewport') {

                        @if (unit(map-get($config, 'content')) != 'px') {

                            margin-#{$direction}: (_get-possible-spacing-value(map-get($config, 'page')) + _get-possible-spacing-value(map-get($config, 'viewport'))) * -1;

                        } @else {

                            margin-#{$direction}: #{'calc((100vw - #{map-get($config, 'content')}) / -2)'};

                        }

                    } @else {

                        @if (str-index(#{map-get($config, 'page')}, 'minmax')) {

                            margin-#{$direction}: #{'calc((100vw - #{map-get($config, 'content')}) / -2 / 2)'};

                            $minPageWidth: str-slice(#{map-get($config, 'page')}, 8, (str-index(#{map-get($config, 'page')}, "px,") + 1));
                            margin-#{$direction}: #{'calc(max(#{$minPageWidth}, ((100vw - #{map-get($config, 'content')}) / 2 / 2)) * -1)'};

                        } @else {

                            margin-#{$direction}: map-get($config, 'page') * -1;

                        }

                    }
                }

            } @else {
                @if ($offsetVisbilityDirection == 'below') {
                    @include possible-mediaquery($breakpoint) {

                        margin-#{$direction}: 0;

                    }
                }
            }

        }

        @if ($offsetVisbilityDirection == 'above' and $offsetWidth == 'page') {
            @include above(2 * $max-page-width - $largest-breakpoint-content-width) {

                margin-#{$direction}: calc(($max-page-width - $largest-breakpoint-content-width) / -2);

            }
        }

    }

}
